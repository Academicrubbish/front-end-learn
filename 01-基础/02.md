### 数据类型

#### 基本数据类型（也称为原始值

- 包括字符串（String）、数字（Number）、布尔值（Boolean）、Undefined和Null。

#### 引用数据类型

- 包括对象（Object）、数组（Array）、函数（Function）、日期（Date）、正则表达式（RegExp）、Map、Set等。

#### 基本数据类型和引用数据类型的不同

- **存储方式：**在给变量赋值时，基本数据类型的值会存在**栈内存**中，可以直接访问；而引用数据类型会将值存在**堆内存**中，并且在**栈内存**里存放引用地址，通过**栈内存**的引用地址来访问值。（下面几个不同点其本质都是这个）

- 复制方式：存储方式的不同造就复制情况的不同，如下图。不论基本数据类型还是引用数据类型，复制都是将**栈内存**里的内容进行赋值的，所以在基本数据类型赋值的时候，是将一个变量的值复制给另一个变量。而引用数据类型赋值时，是按**引用地址**复制给另一个变量，即两个变量指向同一个对象的**引用地址**。

  - ```js
    var a = 1;
    var b = a;
    a = 2;
    console.log(a); //2
    console.log(b); //1
    
    var arr1 = [1,2];
    var arr2 = arr1;
    arr1.push(3)
    console.log(arr1); // [1,2,3]
    console.log(arr2); // [1,2,3]
    ```

- 可变性：基本数据类型是不可变的，一旦创建就不可修改，对其进行操作会返回一个新的值。而引用数据类型是可变的，可以通过改变对象的属性来修改对象的值。

  - ```js
    //基本数据类型的不可变性
    let num1 = 10;
    let num2 = num1 + 5;
    console.log("num1:", num1);  //num1:10
    console.log("num2:", num2);  //num2:15
    
    //引用数据类型的可变性
    let obj1 = {name: "Alice"};
    let obj2 = obj1;
    obj2.name = "Charlie"
    console.log("obj1:", obj1);  //obj1: {name: "Charlie"}
    console.log("obj2:", obj2);  //obj2: {name: "Charlie"}
    ```
    

- 判等方式：基本数据类型可以通过`===`（严格相等）或`==`（相等）进行判等，比较的是值是否相等。引用数据类型的判等比较的是引用地址是否相等，即两个引用是否指向同一个对象。
  
  - ```js
    var arr1 = [1,2];
    var arr2 = arr1;
    var arr3 = [1,2];
    console.log(arr1 === arr2) //true
    console.log(arr1 === arr3) //false
    ```
  
- 传递方式：基本数据类型作为函数参数时，是按值传递的，即函数内部对参数的修改不会影响外部的变量。引用数据类型作为函数参数时，是按引用传递的，即函数内部对参数的修改会影响到外部的变量。

### 数据类型检测`typeof`

- `typeof`对引用数据类型会检测为 'object' ，这个'object' 并不代表对象，而是指代引用数据类型

- null为什么也是'object' ，历史遗留问题，一开始null是被当做空对象占位符发明出来的，后来null引申为出空值的意思，但是`typeof`仍然检测为'object'

  - ```js
    console.log(typeof 2); // number
    console.log(typeof true); // boolean
    console.log(typeof 'str'); // string
    console.log(typeof []); // object
    console.log(typeof function() {}); // function
    console.log(typeof {}); // object
    console.log(typeof undefined); // undefined
    console.log(typeof null); // null
    
    console.log(typeof {}); // object
    console.log(typeof []); // object
    console.log(typeof new Date()); // object
    console.log(typeof new Set()); // object
    console.log(typeof new Map()); // object
    console.log(typeof Symbol()); // symbol
    console.log(typeof /abc/); // object
    console.log(typeof function() {}); // function
    console.log(typeof null); // object
    
    //特殊情况
    //在变量未声明时直接使用会报错,但是有一种情况不会报错
    typeof(a) // 'undefined' 字符串形式
    typeof(typeof(a)) // 'string'
    ```


### 类型转换

#### 显式类型转换

##### `Number(mix)`

- 将参数 `mix` 转换为数字类型。如果 `mix` 是一个数字字符串，将其转换为对应的数字；如果 `mix` 是一个布尔值，`true` 转换为 1，`false` 转换为 0；如果 `mix` 是一个对象，会调用该对象的 `valueOf()` 方法并尝试将返回值转换为数字；否则，返回 `NaN`。

  - ```js
    //数字字符串转换为数字
    console.log(Number('123')); //输出：123
    
    //布尔值转换为数字
    console.log(Number(true)); //输出：1
    console.log(Number(false)); //输出：0
    
    //对象不能转换为数字
    const obj1 = {}
    console.log(Number(obj1)); //输出：NaN
    
    //特殊值转化为数字
    console.log(Number(undefined)); //输出：NaN
    console.log(Number(null)); //输出：0
    console.log(Number(NaN)); //输出：NaN
    console.log(Number("")); //输出：0
    
    //非数字字符串无法转换为数字
    console.log(Number('abc')); //输出：NaN
    
    //对象调用valueOf（）方法并尝试转换为数字
    const obj2 = {
        valueOf（） {
        	return 456
    	}
    }
    console.log(Number(obj2)); //输出：456
    ```

##### `parseInt(string, radix)`

- 将字符串 `string` 转换为整数。可选参数 `radix` 表示进制，默认为 10。该方法从字符串的开头开始解析，直到遇到非数字字符为止。如果无法解析出有效的整数，则返回 `NaN`。**将目标进制转化为10进制**

  - ```js
    //将数字字符串转换为对应的整数，直到遇到非数字字符为止
    console.log(parseInt("123")) //输出: 123
    
    //支持指定进制数进行转换
    console.log(parseInt("1010", 2)) //输出: 10
    console.log(parseInt("FF", 16)) //输出: 255
    
    //浮点数只保留整数部分
    console.log(parseInt(3.7)) //输出: 3
    console.log(parseInt("3.24")) //输出: 3
    
    //特殊值转换为NaN
    console.log(parseInt("abc")) //输出: NaN
    console.log(parseInt("")) //输出: NaN
    
    //可以解析带有正负号的字符串，并返回对应的数字
    console.log(parseInt("+100")) //输出: 100
    console.log(parseInt("-200")) //输出: -200
    
    //如果第一个字符无法识别为数字则返回NaN
    console.log(parseInt("hello")) //输出: NaN
    //如果第一个字符能识别为数字，则直到遇到非数字字符为止
    console.log(parseInt("100px")) //输出: 100
    ```

##### `parseFloat(string)`

- 将字符串 `string` 转换为整数。该方法从字符串的开头开始解析，直到遇到非数字字符为止。如果无法解析出有效的浮点数，则返回 `NaN`。

##### `toString(radix)`

- 将数字转换为字符串。可选参数 `radix` 表示进制，默认为 10。该方法将数字转换为指定进制的字符串表示形式。**将10进制转化为目标进制**
  - 例题：将10101010的2进制转化为16进制
  
    - ```js
      parseInt(10101010,2).toString(16)  //'aa'
      ```
  
  - ```js
    // 数字转换为字符串
    console.log((123).tostring()); // 输出:"123"
    
    //指定进制数进行转换
    console.log((255).tostring(16)); // 输出: "ff"
    console.log((10).tostring(2)); // 输出:"1010"
    
    //特殊值转换为字符串
    console.log(null.tostring()); // 报错
    console.log(undefined.tostring()); //报错
    console.log(NaN.tostring()); // 输出:"NaN"
    console.1og("".tostring()); // 输出:""
    
    //可以将函数转换为字符串
    function myFunction() {
        console.log("He1lo World!");
    }
    console.log(myFunction.tostring()); // 输出函数的源代码
    
    // 对象调用 tostring() 方法并尝试转换为字符串
    const obj1 = {
        tostring() {
            return "hello"
        }
    }
    console.log(obj1.tostring()); // 输出:"hello"
    ```
  

##### `String(mix)`

##### `Boolean()`

#### 隐式类型转换

##### `isNaN` 

- 使用时，隐式调用`Number`方法，再和`NaN`进行比较

  - ```js
    // 判断非数字值
    console.log(isNaN("hello")); //Number("hello") => NaN == NaN 输出：true
    console.log(isNaN(""));  //Number("") => 0 == NaN 输出：false
    
    // 判断数字值
    console.log(isNaN(123)); //Number(123) => 123 == NaN 输出：false
    console.log(isNaN(-Infinity));//Number(-Infinity) => -Infinity == NaN 输出：false
    
    // 特殊值
    console.log(isNaN(undefined)); //Number(undefined) => NaN == NaN 输出：true
    console.log(isNaN(null)); //Number(null) => 0 == NaN 输出：false
    
    //字符串转换为数字
    console.log(isNaN("123")); //Number("123") => 123 == NaN 输出：false
    console.log(isNaN("3.14")); //Number("3.14") => 3.14 == NaN 输出：false
    console.log(isNaN("-Infinity")); //Number("-Infinity") => -Infinity == NaN 输出：false
    
    // 布尔值转换为数字
    console.log(isNaN(true)); //Number(true) => 1 == NaN 输出：false
    console.log(isNaN(false)); //Number(false) => 0 == NaN 输出：false
    ```

##### `++/--`   `+/-`   (一元正负)

- `++/--` 和 `-` 使用时，隐式调用`Number`方法

  - ```js
    //数字类型转换
    var a = 123
    console.log(++a) //类似于 ++Number(123) => 124
    console.log(--a) //类似于 --Number(124) => 123
    console.log(-a) //类似于 -Number(123) => -123
    
    //数字字符串类型转换
    var b = '123'
    var c = '123'
    var d = '123'
    console.log(++b) //类似于 ++Number('123') => 124
    console.log(--c) //类似于 --Number('123') => 122
    console.log(-d) //类似于 -Number('123') => -123
    
    //字符串类型转换
    var e = 'abc'
    console.log(++b) //类似于 ++Number('abc') => NaN
    ```

- `+ `  使用时，隐式调用`String`方法，在 `+` 两边只要出现字符串类型，就会调用`String`方法走拼接；只有在 `+` 两边都是`number`类型的，才会调用`Number`方法进行加法运算

  - ```js
    let str1 = "Hello";
    let str2 = "World";
    let result = str1 + str2; // 拼接字符串
    console.log(result); // 输出: "HelloWorld"
    
    let num1 = 5;
    let num2 = 10;
    let sum = num1 + num2; // 加法运算
    console.log(sum); // 输出: 15
    
    let str = "Hello";
    let num = 10;
    let result = str + num; // 字符串拼接
    console.log(result); // 输出: "Hello10"
    ```

##### ` - * / % `

- ` - * / % `使用时，隐式调用`Number`方法

##### `&& || ！`

- ` && || ！`使用时，隐式调用`Boolean`方法

##### `< > <= >= == !=` 

- `< > <= >= == !=` 转换过程中，会隐式调用`Number`方法进行比较，但是最终返回结果会隐式调用`Boolean`，返回Boolean值

- `== !=`比较特殊，当两边类型相同时，会直接进行比较

  - ```js
    // < > <= >=
    let strNum = "10";
    let num = 5;
    
    console.log(strNum > num); // 输出: true
    
    console.log(10 > 5); // 输出: true
    console.log(5 <= 3); // 输出: false
    
    console.log(true > false); // Number(true) > Number(false)  => 1 > 0 输出: true
    console.log(100 > 10 > 8); // Number(100) > Number(10) > Number(8) => Number(true) > Number(8) => 0 > 8 输出false 
    
    // == !=
    console.log(5 == '5'); // 输出: true
    console.log(5 != '5'); // 输出: false
    
    console.log('abc' == 'abc'); // 输出: true
    
    //特殊情况
    console.log(undefined > 0) // 输出: false
    console.log(undefined < 0) // 输出: false
    console.log(undefined = 0) // 输出: false
    console.log(null > 0) // 输出: false
    console.log(null < 0) // 输出: false
    console.log(null = 0) // 输出: false
    console.log(undefined == null) // 输出: true
    console.log(undefined == undefined) // 输出: true
    console.log(null == null) // 输出: true
    console.log(NaN == NaN) // 输出: false
    ```

#### 不发生类型转换

##### `=== 和 !==`

- ```js
  console.log(1 === 1) // 输出 true
  console.log(1 === '1') // 输出 false
  console.log(undefined === null) // 输出: false
  console.log(NaN == NaN) // 输出: false
  ```

#### 练手题

- ```js
  console.log(typeof(a));
  console.log(typeof(undefined));
  console.log(typeof(NaN));
  console.log(typeof(null));
  console.log(typeof(NaN));
  var a = '123abc'
  console.log(typeof(+a));
  console.log(typeof(!!a));
  console.log(typeof(a + ""));
  console.log(1 == '1');
  console.log(NaN == NaN);
  console.log(NaN == undefined);
  console.log('11' + 11);
  console.log(1 === '1');
  console.log(parseInt("123abc"));
  var num = 123123.345678
  console.log(num.toFixed(3));
  console.log(typeof(typeof(a)))
  ```

### 函数Function

#### 定义

##### 函数声明

```js
function test() {} //声明一个函数test
```

##### 函数表达式

```js
//命名函数表达式
var test = function abc() {} //表达式就是忽略'abc'这个名字的，定义完了之后充当表达式，就不能充当函数体
//test.name => abc

//匿名函数表达式 --- "函数表达式"一般指匿名...
var demo = function () {}
//demo.name => demo
```

#### 组成形式和参数

```js
function sum(a,b) { //a,b称形参
    
    //arguments -- [1,2,3] //实参列表
    //arguments[0] == a
    //arguments[1] == b
    
    //sum.length //形参长度 2
    
}
sum(1,2,3) //1，2称实参

//例：判断形参和实参谁多
function test (a,b,c,d) {
    if(test.length > arguments.length) {
        console.log('形参多了')
    }else if(test.length < arguments.length) {
        console.log('实参多了')
    }else {
        console.log('一样多')
    }
}
//例：求和
function sum() {
    var result = 0
    for(let i = 0; i < arguments.length; i++){
        result += arguments[i]
    }
    return result
}
sum(1,2,3,4,5,6)
```

- `arguments` 对象类似于一个数组，但并不是一个真正的数组。它具有索引、length 属性以及一些数组方法（例如 `arguments.length`），但它没有数组特有的方法，比如 `push()` 和 `pop()`。

  通过 `arguments` 对象，你可以在函数内部访问所有传递给函数的参数，而无需提前定义函数形参。这对于接收可变数量的参数或者不知道函数会接收多少个参数的情况特别有用。

  - ```js
    //ES6有一种写法，比较通用，功能和arguments类似，arg 是一个真正的数组，通过函数形参收集传入的参数；而 arguments 是一个类数组对象，可以直接通过索引访问传入的参数。
    function sum(...arg) {
        console.log(arg) //也是实参列表数组
    }
    ```

- 函数的形参和 `arguments` 对象之间有一种映射关系；但是形参多了，没有对应的实参，则没有映射关系。

  - ```js
    function example(a, b, c) {
      console.log(arguments[0]); // 输出：1
      console.log(arguments[1]); // 输出：2
      console.log(arguments[2]); // 输出：3
    
      console.log(a);            // 输出：1
      console.log(b);            // 输出：2
      console.log(c);            // 输出：3
    
      a = 4;
      console.log(arguments[0]); // 输出：4
      console.log(a);            // 输出：4
    
      arguments[1] = 5;
      console.log(b);            // 输出：5
      console.log(arguments[1]); // 输出：5
    }
    
    example(1, 2, 3);
    
    function sum (a,b) {
        b = 2
        console.log(arguments[1]) //打印：undefined
    }
    sum(1)
    ```

#### 返回值和递归

- return，终止函数和返回变量两个功能

  - ```js
    //考察知识点，递归和返回值
    //例：n的阶乘
    function jc(n) {
        if(n == 1) {
            return 1
        }
        return n * jc(n-1)
    }
    
    //例：斐波那契数列
    function Fibonacci(n) {
        if(n == 2 || n == 1) {
            return 1
        }
        return Fibonacci(n-1) + Fibonacci(n-2)
    }
    ```

#### 作用域

- 作用域定义：变量（变量作用域又称上下文）和函数生效（能被访问）区域
- 全局、局部变量
- 作用域的访问顺序

#### js运行三部曲

##### 语法分析

- 执行前会通篇扫描一遍，确保没有语义错误，这个过程被称为语法分析

##### 预编译

###### 预编译前奏

- imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象所有。

- 一切声明的全局变量，全是window的属性。

  - ```js
    //情况1
    a = 1;  //a = 1就是未经声明就赋值，a就成为了全局变量，即window.a == 1
    
    //情况2
    var a = b = 2;
    
    //拆分成
    var a
    b = 2;  //b = 2就是未经声明就赋值，b就成为了全局变量，即window.b == 2
    a = b;
    
    //情况3
    function test () {
        var a = b = 2; //未经声明就赋值，b就成为了全局变量
    }
    test()
    console.log(b) //打印 2
    
    //声明全局变量
    var d = 3;  //window.d == 3
    ```

###### 预编译四部曲

1. **创建AO对象** Activation Object （执行期上下文）

2. 找**形参**和**变量声明**，将**变量名**和**形参名**作为**AO属性名**，**值为undefined**

3. **将实参值和形参统一**

4. 在函数体里面找**函数声明** (function 方法名 () {})，赋值**函数体**
- ```js
   //例1：
   function fn(a) {
       console.log(a);  // function a () {}
       var a = 123;
       console.log(a);  // 123
       function a () {}
       console.log(a);  // 123
       var b = function () {}
       console.log(b);  // function () {}
       function d () {}
   }
   fn(1)
   ```

   - 预编译生成最终的AO对象 （根据预编译顺序，从左往右）![](assets\Snipaste_2024-01-07_12-24-22.png)

   - 执行代码 （从上往下）![](assets\Snipaste_2024-01-07_12-30-57.png)

- ```js
      //练手题
       function test (a, b) {
           console.log(a);//1      //AO {  代码执行前AO
           c = 0;                  //  a: 1,
           var c;                  //  b: function b () {},
           a = 3;                  //  c: undefined,
           b = 2;                  //  d: function d () {}
           console.log(b);//2      //}
           function b () {}
           function d () {}
           console.log(b);//2
       }
       test(1)
  ```

- 全局也有预编译 (没有形参和实参) ，生成GO对象 Global Object；GO === window

  - ```js
    function test() {
    	var a = b = 123;  //b未声明属于全局变量
    }
    
    test()
    
    //执行前
    AO { 
        a: undefined
    }
    
    //执行后
    GO {
        b: 123
    }
    AO {
        a: 123
    }
    ```


##### 解释执行
